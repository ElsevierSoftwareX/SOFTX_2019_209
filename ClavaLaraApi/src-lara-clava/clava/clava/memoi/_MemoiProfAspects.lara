/**
 * 		Finds the target function and gets its return type.
 * 
 * @aspect
 * @private
 * */
aspectdef _Memoi_FindType
	input
		targetName
	end
	output
		foundType = ''
	end

	var $functionType = undefined;

	// TODO: get function directly
	select stmt.call{targetName} end
	apply
		$functionType = $call.decl.functionType;
	end

	if(_isValidMemoi($functionType)) {
		foundType = $functionType.returnType.code;
	}
end

/**
 * 		Checks if the target function is valid.
 *
 *	The constraints are:
 *	1) it has only a single parameter;
 *	2) the parameter and return type are both T;
 *	3) T is one of {int, float, double};.
 **/
function _isValidMemoi($functionType) {

	var $returnType = $functionType.returnType;
	var paramTypes = $functionType.paramTypes;

	if(paramTypes.length != 1) {
		return false;
	}

	if(paramTypes[0].code != $returnType.code) {
		return false;
	}
	
	return true;
}


/**
 * 		Makes a single global wrapper for all calls of the target
 * 	function.
 * 
 * @aspect
 * @private
 * */
aspectdef _Memoi_GlobalWrapper
	input
		targetName,
		wrapperName,
		monitorType,
		monitorName,
		id,
		reportDir,
		dataType
	end
	
	// make the wrapper
	select stmt.call{targetName} end
	apply
		exec wrap(wrapperName);
	end
	
	// instrument the wrapper
	call _Memoi_InstrumentWrapper(wrapperName, monitorName, monitorType);
	
	// setup
	call _Memoi_Setup(monitorName, monitorType, targetName, id, reportDir, dataType, ['global']);
end

/**
 * 		Makes an individual wrapper for each call of the target
 * 	function.
 * 
 * @aspect
 * @private
 * */
aspectdef _Memoi_IndividualWrapper
	input
		targetName,
		wrapperNameBase,
		monitorType,
		monitorNameBase,
		idBase,
		reportDir,
		dataType
	end
	
	var counter = 0;
	select file.stmt.call{targetName} end
	apply
		
		// make the wrapper
		var wrapperName = wrapperNameBase + '_' + counter;
		exec wrap(wrapperName);
					
		// instrument the wrapper
		var monitorName = monitorNameBase + '_' + counter;
		call _Memoi_InstrumentWrapper(wrapperName, monitorName, monitorType);
		
		// make call site info
		var callSiteInfo = $file.name + ':' + $call.line + ':' + $call.column;
		
		// setup
		var id = idBase + '_' + counter;
		call _Memoi_Setup(monitorName, monitorType, targetName, id, reportDir, dataType, [callSiteInfo]);
		
		counter++;
	end
end

/**
 * 		Instruments a single wrapper with the calls to the memoization profiling
 * library. Adds declaration to the monitor. Also adds the needed header include
 * to the file.
 * 
 * @aspect
 * @private
 * */
aspectdef _Memoi_InstrumentWrapper
	input
		wrapperName,
		monitorName,
		monitorType
	end
	
	select file.function{wrapperName}.stmt.call end
	apply
		var code = 'mp_inc(' + monitorName;
		var firstParam = $function.params[0].name;
		for (var $param of $function.params) {
			code += ', &' + $param.name;
		}
		code += ', &result);';
		insert after code;

		$file.exec addGlobal(monitorName, monitorType, 'NULL');
		
		$file.exec addInclude("MemoiProfiler.h", false);
		$file.exec addInclude('stdlib.h', true);
	end
end

/**
 * 		Performs the setup needed for the instrumentation with the memoization
 * profiling library in the main file. This includes declaring and initializing
 * the monitor, printing the report, and destroying the monitor.
 * 
 * @aspect
 * @private
 * */
aspectdef _Memoi_Setup

	input
		monitorName,
		monitorType,
		funcName,
		id,
		dir,
		type,
		callSiteInfo
	end

	select file.function{'main'}.body end
	apply
		call _Memoi_AddCallSiteInfo($body, callSiteInfo, monitorName);
		$body.exec insertBegin(%{[[monitorName]] = mp_init("[[funcName]]", "[[id]]", [[type]]);}%);

		/* add functions to print and clean up at every return on main */
		$function.exec insertReturn(%{mp_to_json([[monitorName]], make_report_path("[[dir]]", "[[id]]"));}%);
		$function.exec insertReturn(%{[[monitorName]] = mp_destroy([[monitorName]]);}%);

		$file.exec addGlobal(monitorName, monitorType, 'NULL');

		$file.exec addInclude('MemoiProfiler.h', false);
		$file.exec addInclude('stdlib.h', true);
	end
end

aspectdef _Memoi_AddCallSiteInfo
	input $mainBody, callSiteInfo, monitorName end
	
	// call site info
	if(callSiteInfo === undefined) {
		callSiteInfo = ['global'];
	}
	
	checkArray(callSiteInfo);
	
	var length = callSiteInfo.length;
	var code = 'mp_add_call_sites(' + monitorName + ', ' + length ;
	for(var i of callSiteInfo) {
		code += ', "' + i + '"';
	}
	code += ');';
	
	$mainBody.exec insertBegin(code);
end

/**
 * 		Inserts the functions needed to make the report file path.
 * 	@aspect
 *	@private
 * */
aspectdef _Memoi_AddReportCode
	select file.function{'main'}.body end
	apply
		$function.insert before _Memoi_ReportPath();
	end	
end

/**
 * 		Template with the code needed to make the path of the report file with a
 * timestamp.
 * 
 * @codedef
 * @private
 * */
codedef _Memoi_ReportPath %{
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

static const char* timestamp() {
    
    size_t length = 16;
    char* stamp = malloc(length);
    
    time_t current_time = time(NULL);
    struct tm * tm = localtime(&current_time);
    
    snprintf(stamp, length, "%d%02d%02d_%02d%02d%02d", tm->tm_year + 1900, tm->tm_mon + 1, tm->tm_mday, tm->tm_hour, tm->tm_min, tm->tm_sec);
    
    return stamp;
}

static const char* make_report_path(const char* dir, const char* id) {
    
    const char * stamp = timestamp();
    const char * ext = ".json";
    const char * sep = "/";
    const char * under = "_";
    
    size_t stamp_len = strlen(stamp);
    size_t ext_len = strlen(ext);
    size_t sep_len = strlen(sep);
    size_t under_len = strlen(under);
    size_t dir_len = strlen(dir);
    size_t id_len = strlen(id);
    
    size_t total_len = stamp_len + ext_len + sep_len + under_len + dir_len + id_len + 1; // 1 is for the \0
    
    char * path = malloc(total_len);
    
    snprintf(path, total_len, "%s%s%s%s%s%s", dir, sep, stamp, under, id, ext);
    
    free((void*)stamp);
    
    return path;
}
}%
end
