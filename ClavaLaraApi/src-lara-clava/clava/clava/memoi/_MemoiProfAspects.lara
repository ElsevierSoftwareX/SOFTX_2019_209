import clava.memoi._MemoiProfHelper;

/**
 * 		Finds possible targets for memoization. Filters results based
 * 	on the given predicate function (or uses default).
 * */
aspectdef _Memoi_FindTargets

	input filter end
	output targets = [] end
	
	// use default predicate if user doesn't provide one
	if(filter === undefined) {
		filter = _isValidMemoi;
	}
	
	var seen = {};
	
	select stmt.call end
	apply
		var sig = $call.function.signature;
		
		if(seen[sig] !== undefined) {
			continue;
		}
					
		var valid = filter($call, seen);
		if(valid) {
			targets.push(sig);
		}
	end
end

/**
 * 		Finds the target function and gets its return type.
 * 
 * @aspect
 * @private
 * */
aspectdef _Memoi_FindType
	input
		targetSig
	end
	output
		foundType = ''
	end

	select stmt.call{signature === targetSig} end
	apply
		if(_isValidMemoi($call)) {
			var $functionType = $call.function.functionType;
			foundType = $functionType.returnType.code;
			return;
		}
	end
end

aspectdef _Memoi_CheckGlobalAccess
	input $def end
	
	select $def.varref end
	apply
		println($varref.code);
	end
end

/**
 * 		Checks if the target function is valid.
 *
 *	The constraints are:
 *	1) it has only a single parameter;
 *	2) the parameter and return type are both T;
 *	3) T is one of {int, float, double};
 * 	4) It doesn't access global state;
 *	5) It doesn't call non-valid functions. TODO
 **/
function _isValidMemoi($call, seen) {
	
	var $func = $call.function;
	var $functionType = $func.functionType;
	var $returnType = $functionType.returnType;
	var paramTypes = $functionType.paramTypes;
	var sig = $func.signature;

	// 1) it has only a single parameter
	if(paramTypes.length != 1) {
		
		debug(sig + ' - has more than 1 parameter');
		
		if(seen !== undefined) {
			seen[sig] = false;
		}
		return false;
	}
	
	// 2) the parameter and return type are both T
	if(paramTypes[0].code != $returnType.code) {

		debug(sig + ' - parameter and return type are different');
		
		if(seen !== undefined) {
			seen[sig] = false;
		}
		return false;
	}
	
	// 3) T is one of {int, float, double}
	if(!_testType($returnType, ['int', 'float', 'double'])) {
		
		debug(sig + ' - type is not supported: ' + $returnType.code);
		
		if(seen !== undefined) {
			seen[sig] = false;
		}
		return false;
	}
	
	// Try to get the definition
	var $def = $call.definition;
	if($def === undefined) {
		
		if(!_isWhiteListed(sig)) {
			
			debug(sig + ' - definition not found, not whitelisted');
			
			if(seen !== undefined) {
				seen[sig] = false;
			}
			return false;
		} else {

			if(seen !== undefined) {
				seen[sig] = true;
			}
			return true;
		}
	}
	
	// 4) It doesn't access global state (unless constants)
	var varRefs = $def.descendants('varref');
	for(var $ref of varRefs) {
	
		var $varDecl = $ref.declaration;
		
		if($varDecl.isGlobal && (!$ref.type.constant || $ref.type.isPointer)) {
			
			debug(sig + ' - accesses non-const global variable ' + $ref.code);
	
			if(seen !== undefined) {
				seen[sig] = false;
			}
			return false;
		}
	}
	
	// 5) It doesn't call non-valid functions
	
	// Everything checked OK
	if(seen !== undefined) {
		seen[sig] = true;
	}
	return true;
}

/**
 * 		Makes a single global wrapper for all calls of the target
 * 	function.
 * 
 * @aspect
 * @private
 * */
aspectdef _Memoi_GlobalWrapper
	input
		targetSig,
		wrapperName,
		monitorType,
		monitorName,
		id,
		reportDir,
		dataType
	end
	
	// make the wrapper
	select stmt.call{signature === targetSig} end
	apply
		exec wrap(wrapperName);
	end
	
	// instrument the wrapper
	call _Memoi_InstrumentWrapper(wrapperName, monitorName, monitorType);
	
	// setup
	call _Memoi_Setup(monitorName, monitorType, targetSig, id, reportDir, dataType, ['global']);
end

/**
 * 		Makes an individual wrapper for each call of the target
 * 	function.
 * 
 * @aspect
 * @private
 * */
aspectdef _Memoi_IndividualWrapper
	input
		targetSig,
		wrapperNameBase,
		monitorType,
		monitorNameBase,
		idBase,
		reportDir,
		dataType
	end
	
	var counter = 0;
	select file.stmt.call{signature === targetSig} end
	apply
		
		// make the wrapper
		var wrapperName = wrapperNameBase + '_' + counter;
		exec wrap(wrapperName);
					
		// instrument the wrapper
		var monitorName = monitorNameBase + '_' + counter;
		call _Memoi_InstrumentWrapper(wrapperName, monitorName, monitorType);
		
		// make call site info
		var callSiteInfo = $file.name + ':' + $call.line + ':' + $call.column;
		
		// setup
		var id = idBase + '_' + counter;
		call _Memoi_Setup(monitorName, monitorType, targetSig, id, reportDir, dataType, [callSiteInfo]);
		
		counter++;
	end
end

/**
 * 		Instruments a single wrapper with the calls to the memoization profiling
 * library. Adds declaration to the monitor. Also adds the needed header include
 * to the file.
 * 
 * @aspect
 * @private
 * */
aspectdef _Memoi_InstrumentWrapper
	input
		wrapperName,
		monitorName,
		monitorType
	end
	
	select file.function{wrapperName}.stmt.call end
	apply
		var code = 'mp_inc(' + monitorName;
		var firstParam = $function.params[0].name;
		for (var $param of $function.params) {
			code += ', &' + $param.name;
		}
		code += ', &result);';
		insert after code;

		$file.exec addGlobal(monitorName, monitorType, 'NULL');
		
		$file.exec addInclude("MemoiProfiler.h", false);
		$file.exec addInclude('stdlib.h', true);
	end
end

/**
 * 		Performs the setup needed for the instrumentation with the memoization
 * profiling library in the main file. This includes declaring and initializing
 * the monitor, printing the report, and destroying the monitor.
 * 
 * @aspect
 * @private
 * */
aspectdef _Memoi_Setup

	input
		monitorName,
		monitorType,
		targetSig,
		id,
		dir,
		type,
		callSiteInfo
	end

	select file.function{'main'}.body end
	apply
		call _Memoi_AddCallSiteInfo($body, callSiteInfo, monitorName);
		$body.exec insertBegin(%{[[monitorName]] = mp_init("[[targetSig]]", "[[id]]", [[type]]);}%);

		/* add functions to print and clean up at every return on main */
		$function.exec insertReturn(%{mp_to_json([[monitorName]], make_report_path("[[dir]]", "[[id]]"));}%);
		$function.exec insertReturn(%{[[monitorName]] = mp_destroy([[monitorName]]);}%);

		$file.exec addGlobal(monitorName, monitorType, 'NULL');

		$file.exec addInclude('MemoiProfiler.h', false);
		$file.exec addInclude('stdlib.h', true);
	end
end

aspectdef _Memoi_AddCallSiteInfo
	input $mainBody, callSiteInfo, monitorName end
	
	// call site info
	if(callSiteInfo === undefined) {
		callSiteInfo = ['global'];
	}
	
	checkArray(callSiteInfo);
	
	var length = callSiteInfo.length;
	var code = 'mp_add_call_sites(' + monitorName + ', ' + length ;
	for(var i of callSiteInfo) {
		code += ', "' + i + '"';
	}
	code += ');';
	
	$mainBody.exec insertBegin(code);
end

/**
 * 		Inserts the functions needed to make the report file path.
 * 	@aspect
 *	@private
 * */
aspectdef _Memoi_AddReportCode
	select file.function{'main'}.body end
	apply
		$function.insert before _Memoi_ReportPath();
	end	
end

/**
 * 		Template with the code needed to make the path of the report file with a
 * timestamp.
 * 
 * @codedef
 * @private
 * */
codedef _Memoi_ReportPath %{
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

static const char* timestamp() {
    
    size_t length = 16;
    char* stamp = malloc(length);
    
    time_t current_time = time(NULL);
    struct tm * tm = localtime(&current_time);
    
    snprintf(stamp, length, "%d%02d%02d_%02d%02d%02d", tm->tm_year + 1900, tm->tm_mon + 1, tm->tm_mday, tm->tm_hour, tm->tm_min, tm->tm_sec);
    
    return stamp;
}

static const char* make_report_path(const char* dir, const char* id) {
    
    const char * stamp = timestamp();
    const char * ext = ".json";
    const char * sep = "/";
    const char * under = "_";
    
    size_t stamp_len = strlen(stamp);
    size_t ext_len = strlen(ext);
    size_t sep_len = strlen(sep);
    size_t under_len = strlen(under);
    size_t dir_len = strlen(dir);
    size_t id_len = strlen(id);
    
    size_t total_len = stamp_len + ext_len + sep_len + under_len + dir_len + id_len + 1; // 1 is for the \0
    
    char * path = malloc(total_len);
    
    snprintf(path, total_len, "%s%s%s%s%s%s", dir, sep, stamp, under, id, ext);
    
    free((void*)stamp);
    
    return path;
}
}%
end
