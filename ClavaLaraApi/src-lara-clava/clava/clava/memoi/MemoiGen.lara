import clava.memoi._MemoiGenHelper;

import lara.util.IdGenerator;
import lara.Io;

/**
 * 		Library to generate memoization tables based on the results from
 * 	the memoiprof profiling library.
 * 
 * @constructor
 * 
 * @param {string[]|...string} reports - the paths of the report files
 * */
function MemoiGen(reports) {
	
	this._reportsPaths = arrayFromArgs(arguments);
	this._reports = MemoiGen._readReports(this._reportsPaths);
	this._isDebug = false;
}

/**
 * @constructor
 * 
 * @param {string} dir - the path of the directory containing the report files
 * */
MemoiGen.fromDir = function(dir) {

	checkString(dir);
	
	var files = Io.getFiles(dir, "*.json", false);

	return new MemoiGen(files);
};

/**
 * 		Reads memoization profiling reports and sorts the counts.
 * */
MemoiGen._readReports = function(reportsPaths) {

	var reports = {};
	var counter = 0;
	
	for (var reportPath of reportsPaths) {
		
		var report = fileToJSON(reportPath);
		
		// add the path to uniquely identify this report
		report.path = reportPath;
		
		// add report to map
		MemoiGen._mapReport(reports, report);
		
		counter++;
	}
	
	println('# read reports: ' + counter);
	return MemoiGen._combineReports(reports);
}

/**
 * 		Maps reports into a double map.
 * 		target function -> call site -> list of reports
 * */
MemoiGen._mapReport = function(reportsMap, report) {
	
	if (reportsMap[report.func_name] === undefined) {
		
		reportsMap[report.func_name] = {};
	}
	
	if (reportsMap[report.func_name][report.call_sites] === undefined) {
		
		reportsMap[report.func_name][report.call_sites] = [];
	}
	
	reportsMap[report.func_name][report.call_sites].push(report);
	
}

/**
 * 		Combines reports of the same function and same call site from
 * 	different profiling runs.
 * */
MemoiGen._combineReports = function(originalReports) {
			
	var finalReports = [];
	
	for(var func in originalReports) {
		
		for(var callSite in originalReports[func]) {

			// get old reports for the current <func, call>
			var reports = originalReports[func][callSite];
	
			// new report stores every run info in arrays
			var newReport = {
				func_name : func,
				call_sites : callSite,
				reportCount : reports.length,
				elements : [],
				calls : [],
				hits : [],
				misses : [],			
				counts : {} // counts is temporarily a map to ease the combination
			};
			
			// iterate all old reports
			for(var oldReport of reports) {
				
				// add all info to the corresponding arrays
				newReport.elements.push(oldReport.elements);
				newReport.calls.push(oldReport.calls);
				newReport.hits.push(oldReport.hits);
				newReport.misses.push(oldReport.misses);
				
				// iterate all counts of the old report
				for(var count of oldReport.counts) {
					
					var key = count.key;
					
					// build new counts using the key attribute as a key
					if(newReport.counts[key] === undefined) {
						
						newReport.counts[key] = {
							key : key,
							output : count.output,
							counter : [count.counter]
						};
					} else {
						
						newReport.counts[key].counter.push(count.counter);
					}
				}
			}
			// convert counts from a map to an array
			_convertCounts(newReport);
	
			finalReports.push(newReport);
		}
	}
	
	println('# combined reports: ' + finalReports.length);
	
	return finalReports;
};

/**
 * 		Prints detailed metrics for each <target function, call site>.
 * 		The data is the average of all reports read.
 * */
MemoiGen.prototype.printAverageMetrics = function() {
	
	for(var report of this._reports) {
		
		println('=== profile metrics ===');
		
		println('  > target function: ' + report.func_name);
		println('  > call sites: ' + report.call_sites);
		println('  > report count: ' + report.reportCount);
		
		var unique = mean(report.elements);
		var total = mean(report.calls);
		
		var repetition = 100 * (total - unique) / total;
		
		var averageRepetition = total / unique;
		
		var top3total = totalTopN(report, 3, report.reportCount);
		var top3percentage = top3total / total * 100;
		
		var top5total = totalTopN(report, 5, report.reportCount);
		var top5percentage = top5total / total * 100;
		
		var top10total = totalTopN(report, 10, report.reportCount);
		var top10percentage = top10total / total * 100;
		
		// print metrics
		println('  > unique inputs: ' + unique);
		println('  > total calls: ' + total);
		println('  > repetition: ' + repetition.toFixed(2) + '%');
		println('  > average repetition: ' + averageRepetition.toFixed(4));
		println('  > top 3: ' + top3percentage.toFixed(2) + '%');
		println('  > top 5: ' + top5percentage.toFixed(2) + '%');
		println('  > top 10: ' + top10percentage.toFixed(2) + '%');
		println('  > elements for 5%: ' + elementsForRatio(report, total, 0.05, report.reportCount));
		println('  > elements for 10%: ' + elementsForRatio(report, total, 0.1, report.reportCount));
		println('  > elements for 25%: ' + elementsForRatio(report, total, 0.25,report.reportCount));
		println('  > elements for 50%: ' + elementsForRatio(report, total, 0.5, report.reportCount));
		print('  > bwp:  '); printBwp(report, report.reportCount);
		println('\n');
	}
}

var MemoiApply = {
	ALWAYS : function(report) {
		if(mean(report.elements, report.reportCount) === 0) {
			debug('skipping ' + report.func_name + ' at ' + report.call_sites + ' - no calls');
			return false;
		}
		
		return true;
	}
};

var MemoiInsert = {
	ALL : function(count, report) {
		return true;
	}
};

var MemoiComparator = {
	MEAN: function(count1, count2, total) {
			
		var mean1 = mean(count1.counter, total);
		var mean2 = mean(count2.counter, total);
		
		if(mean1 > mean2) {
			return 1;
		} else if (mean1 < mean2) {
			return -1;
		} else {
			return 0;
		}
	}
};


/**
 * 		Sets whether to generate debug code in the final application.
 * */
MemoiGen.prototype.setDebug = function(isDebug) {
	
	isDebug = isDebug === undefined ? false : isDebug;
	
	this._isDebug = isDebug;
}

/**
 * 		Makes a table for each <target function, call site> pair. The
 * 	table will have 2^16 elements and will be indexed by 16-bit keys.
 * 
 * 		Decides whether to apply memoization to that specific call site
 * 	based on the result of the predicate applyPred, which receives the 
 *  entire report. The default predicate is MemoiApply.ALWAYS.
 * 
 * 		Decides whether to include any single element based on the
 * 	result of the predicate insertPred, which receives the count for
 *  that specific element and the entire report. The default predicate
 *  is MemoiInsert.ALL.
 * 
 * 		In case of a collision, decides which element to use based on
 * 	the order of the counts array, which is ordered from the least
 * 	important element to the most important element. The function
 * 	countComparator will be used as the comparator of each pair of
 * 	elements in the array. The default comparison function will sort
 * 	based on the mean and can be found at MemoiComparator.MEAN.
 * */
MemoiGen.prototype.generate = function(applyPred, insertPred, countComparator) {
	
	for(var report of this._reports) {
		
		if(!applyPred(report)) {
			continue;
		}
		
		// define the comparator based on this report
		var comparatorToUse = function(count1, count2){
			return countComparator(count1, count2, report.reportCounter);
		};

		MemoiGen._generate(insertPred, comparatorToUse, report);
	}
}

/**
 * 		Generates the table and supporting code for this report.
 * 		
 * 		Inserts elements in the table based on the predicate insertPred.
 * */
MemoiGen._generate = function(insertPred, countComparator, report) {

	// check isDebug
	
	var callSite = report.call_sites;
	var signature = report.func_name;
	
	if(callSite === 'global') {
		throw "global call site generate is not supported yet";
	} else {

		var wst = call _Memoi_WrapSingleTarget(signature, callSite);
		call _Memoi_InsertTableCode(insertPred, countComparator, report, wst.wrapperName);
	}
}

aspectdef _Memoi_InsertTableCode
	input insertPred, countComparator, report, wrapperName end
	
	select file.function{wrapperName}.call end
	apply
		var table = _makeTableCode(insertPred, countComparator, report, $function);
		insert before table;
		$file.exec addInclude('stdint.h', true);
	end
end

function _makeTableCode(insertPred, countComparator, report, $function) {
	
	
	var numBits = 16; // no. of bits
	var s = Math.pow(2, numBits); // table size
	var firstParam = $function.params[0]; // to be changed!
	
	var collisions = 0;
	var collisionPercentage;
	var maxCollision = 0;
	var hashMaxCollision;
	var coverage;
	var code = "";
	var table = [];
	
	var counts = report.counts;
	counts.sort(countComparator);
	var totalElements = counts.length;
	
	for(var i = 0; i < totalElements; i++) {
		
		var count = counts[i];
		
		if(!insertPred(count, report)) {
			continue;
		}
		
		var hash = _hashFunction(count.key, numBits);
		debug(count.key + ' ' + count.counter + 'x');
		if(table[hash] === undefined) {

			table[hash] = {'key' : count.key,
						'output' : count.output,
						'collisions' : 0,
						'counter' : count.counter};
		} else {

			table[hash].key = count.key;
			table[hash].output = count.output;
			table[hash].counter = count.counter;

			// collisions on this specific position
			table[hash].collisions++;
			if(table[hash].collisions > maxCollision) {maxCollision = table[hash].collisions; hashMaxCollision = hash;}
			
			// total collisions
			collisions++;
		}
	}
	
	return code;
}

_hashFunctionHalf = function(bits64){
	
	var len = bits64.length;
	var hashString = '';
	
	for(var i = 0; i < len / 2; i++) {

		var number = parseInt(bits64.charAt(i), 16) ^ parseInt(bits64.charAt(i+len/2), 16);
		hashString +=  number.toString(16);
	}

	return hashString;
}

_hashFunction = function(bits64, numBits) {
	switch(numBits) {

		case 8:
			var bits32 = _hashFunctionHalf(bits64);
			var bits16 = _hashFunctionHalf(bits32);
			var bits8 = _hashFunctionHalf(bits16);
			return parseInt(bits8, 16);
		case 16:
			var bits32 = _hashFunctionHalf(bits64);
			var bits16 = _hashFunctionHalf(bits32);
			return parseInt(bits16, 16);
		default:
			return bits64;
			break;				
	}
}
