import clava.memoi._MemoiGenHelper;

import lara.Io;

/**
 * 		Library to generate memoization tables based on the results from
 * 	the memoiprof profiling library.
 * 
 * @constructor
 * 
 * @param {string[]|...string} reports - the paths of the report files
 * */
function MemoiGen(reports) {
	
	this._reportsPaths = arrayFromArgs(arguments);
	this._reports = MemoiGen._readReports(this._reportsPaths);
}

/**
 * @constructor
 * 
 * @param {string} dir - the path of the directory containing the report files
 * */
MemoiGen.fromDir = function(dir) {

	checkString(dir);
	
	var files = Io.getFiles(dir, "*.json", false);

	return new MemoiGen(files);
};

/**
 * 		Reads memoization profiling reports and sorts the counts.
 * */
MemoiGen._readReports = function(reportsPaths) {

	var reports = {};
	var counter = 0;
	
	for (var reportPath of reportsPaths) {
		
		var report = fileToJSON(reportPath);
		
		// add the path to uniquely identify this report
		report.path = reportPath;
	
	/*
		// convert counters to integers and sort
		for(var i in report.counts) {
			report.counts[i].counter = parseInt(report.counts[i].counter);
		}
	
		report.counts.sort(function(a, b){
	
			if(a.counter < b.counter)
				return 1;
			else if(a.counter > b.counter)
				return -1;
			else
				return 0;
		});
		
		/**/
		
		// add report to map
		MemoiGen._mapReport(reports, report);
		
		counter++;
	}
	
	println('# read reports: ' + counter);
	return MemoiGen._combineReports(reports);
}

/**
 * 		Maps reports into a double map.
 * 		target function -> call site -> list of reports
 * */
MemoiGen._mapReport = function(reportsMap, report) {
	
	if (reportsMap[report.func_name] === undefined) {
		
		reportsMap[report.func_name] = {};
	}
	
	if (reportsMap[report.func_name][report.call_sites] === undefined) {
		
		reportsMap[report.func_name][report.call_sites] = [];
	}
	
	reportsMap[report.func_name][report.call_sites].push(report);
	
}

/**
 * 		Combines reports of the same function and same call site from
 * 	different profiling runs.
 * */
MemoiGen._combineReports = function(originalReports) {
			
	var finalReports = [];
	
	for(var func in originalReports) {
		
		for(var callSite in originalReports[func]) {

			// get old reports for the current <func, call>
			var reports = originalReports[func][callSite];
	
			// new report stores every run info in arrays
			var newReport = {
				func_name : func,
				call_sites : callSite,
				reportCount : reports.length,
				elements : [],
				calls : [],
				hits : [],
				misses : [],			
				counts : {} // counts is now a map to easy the combination
			};
			
			// iterate all old reports
			for(var oldReport of reports) {
				
				// add all info to the corresponding arrays
				newReport.elements.push(oldReport.elements);
				newReport.calls.push(oldReport.calls);
				newReport.hits.push(oldReport.hits);
				newReport.misses.push(oldReport.misses);
				
				// iterate all counts of the old report
				for(var count of oldReport.counts) {
					
					var key = count.key;
					
					// build new counts using the key attribute as a key
					if(newReport.counts[key] === undefined) {
						
						newReport.counts[key] = {
							key : key,
							output : count.output,
							counter : [count.counter]
						};
					} else {
						
						newReport.counts[key].counter.push(count.counter);
					}
				}
			}
			finalReports.push(newReport);
		}
	}
	
	println('# combined reports: ' + finalReports.length);
	
	return finalReports;
};

/**
 * 		Prints detailed metrics for each <target function, call site>.
 * 		The data is the average of all reports read.
 * */
MemoiGen.prototype.printAverageMetrics = function() {
	
	for(var report of this._reports) {
		
		println('=== profile metrics ===');
		
		println('  > target function: ' + report.func_name);
		println('  > call sites: ' + report.call_sites);
		println('  > report count: ' + report.reportCount);
		
		var unique = mean(report.elements);
		var total = mean(report.calls);
		
		var repetition = 100 * (total - unique) / total;
		
		var averageRepetition = total / unique;
		
		var top3total = totalTopN(report, 3, report.reportCount);
		var top3percentage = top3total / total * 100;
		
		var top5total = totalTopN(report, 5, report.reportCount);
		var top5percentage = top5total / total * 100;
		
		var top10total = totalTopN(report, 10, report.reportCount);
		var top10percentage = top10total / total * 100;
		
		// print metrics
		println('  > unique inputs: ' + unique);
		println('  > total calls: ' + total);
		println('  > repetition: ' + repetition.toFixed(2) + '%');
		println('  > average repetition: ' + averageRepetition.toFixed(4));
		println('  > top 3: ' + top3percentage.toFixed(2) + '%');
		println('  > top 5: ' + top5percentage.toFixed(2) + '%');
		println('  > top 10: ' + top10percentage.toFixed(2) + '%');
		println('  > elements for 5%: ' + elementsForRatio(report, total, 0.05, report.reportCount));
		println('  > elements for 10%: ' + elementsForRatio(report, total, 0.1, report.reportCount));
		println('  > elements for 25%: ' + elementsForRatio(report, total, 0.25,report.reportCount));
		println('  > elements for 50%: ' + elementsForRatio(report, total, 0.5, report.reportCount));
		print('  > bwp:  '); printBwp(report, report.reportCount);
		println('\n');
	}
}
